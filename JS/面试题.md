# JS篇 —— 面试题

## 数据类型
数据类型主要包括两部分：

**基本数据类型**： Undefined、Null、Boolean、Number 和 String
**引用数据类型**： Object (包括 Object 、Array 、Function)
ECMAScript 2015 新增:Symbol(创建后独一无二且不可变的数据类型 )

---
## 判断一个值是什么类型有哪些方法？
* typeof 运算符
* instanceof 运算符
* Object.prototype.toString 方法

---
## null 和 undefined 的区别？
null 表示一个对象被定义了，值为“空值”；
undefined 表示不存在这个值。
1. 变量被声明了，但没有赋值时，就等于undefined。 
2. 调用函数时，应该提供的参数没有提供，该参数等于undefined。
3. 对象没有赋值的属性，该属性的值为undefined。 
4. 函数没有返回值时，默认返回undefined。

---

## undeclared 和 undefined 区别？
- undeclared的变量是程序中不存在且未声明的变量。 如果程序尝试读取未声明变量的值，则会遇到运行时错误。
- undefined的变量是在程序中声明但未赋予任何值的变量，如果程序试图读取未定义变量的值，则返回undefined的值。

---

# NaN 是什么
NaN 即非数值（Not a Number），NaN 属性用于引用特殊的非数字值，该属性指定的并不是不合法的数字。
NaN 属性 与 Number.Nan 属性相同。

---
## 怎么判断一个变量arr的话是否为数组（此题用 typeof 不行）？
arr instanceof Array
arr.constructor == Array
Object.protype.toString.call(arr) == '[Object Array]'

---
## “===、 ==”的区别？
* ==：当且仅当两个运算数相等时，它返回 true，即不检查数据类型
* ===：只有在无需类型转换运算数就相等的情况下，才返回 true，需要检查数据类型

---
## eval是做什么的？
eval() 函数会将传入的字符串当做 JavaScript 代码进行执行。
它的功能是把对应的字符串解析成 JS 代码并运行；
应该避免使用 eval，不安全，非常耗性能（2次，一次解析成 js 语句，一次执行）。

---
## 箭头函数有哪些特点？
不需要function关键字来创建函数
省略return关键字
改变this指向

---
## var、let、const 区别？
var 存在声明提升，声明覆盖。
let 只能在块级作用域内访问。
const 用来定义常量，必须初始化，不能修改（对象特殊）

---
## new操作符具体干了什么呢？
1. 创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型。
2. 属性和方法被加入到 this 引用的对象中。
3. 新创建的对象由 this 所引用，并且最后隐式的返回 this 。

---

## JSON 的了解？
JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。
它是基于JavaScript的一个子集。数据格式简单, 易于读写, 占用带宽小
{'age':'12', 'name':'back'}

---

## documen.write 和 innerHTML 的区别？
document.write 只能重绘整个页面
innerHTML 可以重绘页面的一部分

---

## ajax过程？
(1)创建XMLHttpRequest对象,也就是创建一个异步调用对象.
(2)创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息.
(3)设置响应HTTP请求状态变化的函数.
(4)发送HTTP请求.
(5)获取异步调用返回的数据.
(6)使用JavaScript和DOM实现局部刷新.

---

## 请解释一下 JavaScript 的同源策略？
概念:同源策略是客户端脚本（尤其是Netscape Navigator2.0），其目的是防止某个文档或脚本从多个不同源装载。
这里的同源策略指的是：协议，域名，端口相同，同源策略是一种安全协议。
指一段脚本只能读取来自同一来源的窗口和文档的属性。

---

##  介绍一下闭包和闭包常用场景？
闭包是指有权访问另一个函数作用域中的变量的函数，创建闭包常见方式，就是在一个函数的内部创建另一个函数
使用闭包主要为了设计私有的方法和变量，闭包的优点是可以避免变量的污染，缺点是闭包会常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。在js中，函数即闭包，只有函数才会产生作用域的概念。
闭包有三个特性：
函数嵌套函数
函数内部可以引用外部的参数和变量
参数和变量不会被垃圾回收机制回收
应用场景，设置私有变量的方法
不适用场景：返回闭包的函数是个非常大的函数
闭包的缺点就是常驻内存，会增大内存使用量，使用不当会造成内存泄漏

---

## javascript的内存(垃圾)回收机制？
垃圾回收器会每隔一段时间找出那些不再使用的内存，然后为其释放内存
一般使用标记清除方法(mark and sweep), 当变量进入环境标记为进入环境，离开环境标记为离开环境
垃圾回收器会在运行的时候给存储在内存中的所有变量加上标记，然后去掉环境中的变量以及被环境中变量所引用的变量（闭包），在这些完成之后仍存在标记的就是要删除的变量了
还有引用计数方法(reference counting), 在低版本IE中经常会出现内存泄露，很多时候就是因为其采用引用计数方式进行垃圾回收。引用计数的策略是跟踪记录每个值被使用的次数，当声明了一个 变量并将一个引用类型赋值给该变量的时候这个值的引用次数就加1，如果该变量的值变成了另外一个，则这个值得引用次数减1，当这个值的引用次数变为0的时 候，说明没有变量在使用，这个值没法被访问了，因此可以将其占用的空间回收，这样垃圾回收器会在运行的时候清理掉引用次数为0的值占用的空间。
在IE中虽然JavaScript对象通过标记清除的方式进行垃圾回收，但BOM与DOM对象却是通过引用计数回收垃圾的， 也就是说只要涉及BOM及DOM就会出现循环引用问题。

---

## JavaScript原型，原型链 ? 有什么特点？
每个对象都会在其内部初始化一个属性，就是prototype(原型)，当我们访问一个对象的属性时，
如果这个对象内部不存在这个属性，那么他就会去prototype里找这个属性，这个prototype又会有自己的prototype，
于是就这样一直找下去，也就是我们平时所说的原型链的概念。
关系：instance.constructor.prototype = instance.proto
特点：
JavaScript对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与之相关的对象也会继承这一改变。

---

## 深拷贝和浅拷贝
1. 基本数据类型的赋值不算拷贝
2. 数组和对象的赋值为浅拷贝
3. 解构赋值时，针对一维数组和对象可以看作深拷贝，多维数组为浅拷贝
4. JSON转化后为深拷贝
``` JavaScript
let newList = JSON.parse(JSON.stringify(list));
```
5. 标准深拷贝写法
``` JavaScript
function deepClone(source){
  // [] => Array(基类); {} => Object
  const targetObj = source.constructor === Array ? [] : {};
  for(let keys in source) {
    if(source.hasOwnProperty(keys)){
      // keys => 3
      // 引用数据类型
      if(source[keys] && typeof source[keys] === 'object'){
        targetObj[keys] = source[keys].constructor === Array ? [] : {};
        // 递归
        targetObj[keys] = deepClone(source[keys])
      }
      else{
        // 基本数据类型，直接赋值
        targetObj[keys] = source[keys]
      }
    }
  }
  return targetObj
}
```

***补充知识*** 
*1.hasOwnProperty()函数用于指示一个对象自身(不包括原型链)是否具有指定名称的属性。如果有，返回true，否则返回false。
2.说简单点，它能帮你指向你当前循环的对象，而过滤掉原型链上其它对象，因为在工作中我们很难保证其他人是否会修改原型链，这样做会更为保险。
3.因为 for in 循环总是遍历整个原型链，所以当遍历多继承的对象时效率较低。
4.为了检查某个对象是否拥有不在原型链上的自定义属性，就有必要用到 hasOwnProperty 方法，任何一个对象都具有该方法，它继承自 Object.prototype。
5.当检测某个对象是否拥有某个属性时，hasOwnProperty 是唯一可以完成这一任务的方法，在 for in 循环时，建议增加 hasOwnProperty 进行判断，可以有效避免扩展本地原型而引起的错误。
6.我们无法完全检测某个属性是否是undefined，因为属性有可能存在，但其值为undefined。
7.hasOwnProperty 是Javascript中唯一一个可以处理对象属性而不遍历原型链的方法。
个人认为hasOwnProperty()的主要作用就是在多重循环中过滤掉不符合条件的对象，减少遍历次数，和其他编程语言中的continue和break类似。*

---

## map与set的区别
- set是一种集合数据结构，以[value]形式存储元素
- Map是一种字典数据结构，以[key: value]的形式存储元素

---

## 构造函数与普通函数的区别
1. 命名方式
   构造名称通常首字母大写，普通小写
2. this指向
   构造this会绑定到创建的对象实例上
   普通this属于此函数的调用者
3. 调用方式
   构造函数需要new运算符调用，如果构造没有参数可以省略小括号，如new Object
   普通不需要new，必须要小括号

---

## 创建JavaScript对象的两种方法是什么？
1. 使用“new”关键字来调用函数。
2. open/close花括号。
``` JavaScript
var o = {};
```

---

## 如何创建数组？
``` JavaScript
var myArray = new Array();
var myArray = [];
```

---

## js 如何实现数组去重整理出5种方法。
1. 遍历数组法
最简单的去重方法， 实现思路：新建一新数组，遍历传入数组，值不在新数组就加入该新数组中；注意点：判断值是否在数组的方法“indexOf”是ECMAScript5 方法，IE8以下不支持，需多写一些兼容低版本浏览器代码，源码如下：
``` javascript
// 最简单数组去重法
function unique1(array){
 var n = []; //一个新的临时数组
 //遍历当前数组
 for(var i = 0; i < array.length; i++){
  //如果当前数组的第i已经保存进了临时数组，那么跳过，
  //否则把当前项push到临时数组里面
  if (n.indexOf(array[i]) == -1) n.push(array[i]);
 }
 return n;
}
// 判断浏览器是否支持indexOf ，indexOf 为ecmaScript5新方法 IE8以下（包括IE8， IE8只支持部分ecma5）不支持
if (!Array.prototype.indexOf){
 // 新增indexOf方法
 Array.prototype.indexOf = function(item){
  var result = -1, a_item = null;
  if (this.length == 0){
   return result;
  }
  for(var i = 0, len = this.length; i < len; i++){
   a_item = this[i];
   if (a_item === item){
    result = i;
    break;
   }
  }
  return result;
 }
}
```

2. 对象键值对法
该方法执行的速度比其他任何方法都快， 就是占用的内存大一些；实现思路：新建一js对象以及新数组，遍历传入数组时，判断值是否为js对象的键，不是的话给对象新增该键并放入新数组。注意点： 判断是否为js对象键时，会自动对传入的键执行“toString()”，不同的键可能会被误认为一样；例如： a[1]、a["1"] 。解决上述问题还是得调用“indexOf”。
``` javascript
// 速度最快， 占空间最多（空间换时间）

function unique2(array){
 var n = {}, r = [], len = array.length, val, type;
  for (var i = 0; i < array.length; i++) {
    val = array[i];
    type = typeof val;
    if (!n[val]) {
      n[val] = [type];
      r.push(val);
    } else if (n[val].indexOf(type) < 0) {
      n[val].push(type);
      r.push(val);
    }
  }
  return r;
}
```


3. 数组下标判断法
还是得调用“indexOf”性能跟方法1差不多，实现思路：如果当前数组的第i项在当前数组中第一次出现的位置不是i，那么表示第i项是重复的，忽略掉。否则存入结果数组。
``` javascript
function unique3(array){
 var n = [array[0]]; //结果数组
 //从第二项开始遍历
 for(var i = 1; i < array.length; i++) {
  //如果当前数组的第i项在当前数组中第一次出现的位置不是i，
  //那么表示第i项是重复的，忽略掉。否则存入结果数组
  if (array.indexOf(array[i]) == i) n.push(array[i]);
 }
 return n;
}
```

4. 排序后相邻去除法
虽然原生数组的”sort”方法排序结果不怎么靠谱，但在不注重顺序的去重里该缺点毫无影响。实现思路：给传入数组排序，排序后相同值相邻，然后遍历时新数组只加入不与前一值重复的值。
``` javascript
// 将相同的值相邻，然后遍历去除重复值
function unique4(array){
 array.sort();
 var re=[array[0]];
 for(var i = 1; i < array.length; i++){
  if( array[i] !== re[re.length-1])
  {
   re.push(array[i]);
  }
 }
 return re;
}
```

5. 优化遍历数组法
源自外国博文，该方法的实现代码相当酷炫；实现思路：获取没重复的最右一值放入新数组。（检测到有重复值时终止当前循环同时进入顶层循环的下一轮判断）
``` javascript
// 思路：获取没重复的最右一值放入新数组

function unique5(array){
 var r = [];
 for(var i = 0, l = array.length; i < l; i++) {
  for(var j = i + 1; j < l; j++)
   if (array[i] === array[j]) j = ++i;
  r.push(array[i]);
 }
 return r;
}
```

---

## 什么是变量提升（Variable Hoisting）？
变量提升指的是，无论是哪里的变量在一个范围内声明的，那么JavaScript引擎会将这个声明移到范围的顶部。如果在函数中间声明一个变量，例如在某一行中赋值一个变量：
``` javascript
function foo()
{
 // 此处省略若干代码
 var a = "abc";
}
```
实际上会这样运行代码：
``` javascript
function foo()
{
 var a;
 // 此处省略若干代码
 a = "abc";
}
```

---

## 全局变量有什么风险，以及如何保护代码不受干扰？
全局变量的危险之处在于其他人可以创建相同名称的变量，然后覆盖你正在使用的变量。这在任何语言中都是一个令人头疼的问题。预防的方法也有很多。其中最常用的方法是创建一个包含其他所有变量的全局变量：
``` javascript
var applicationName = {};
// 然后，每当你需要创建一个全局变量的时候，将其附加到对象上即可。
applicationName.myVariable = "abc";

//还有一种方法是将所有的代码封装到一个自动执行的函数中，这样一来，所有声明的变量都声明在该函数的范围内。
(function(){
 var a = "abc";
})();

```

---

## 如何通过JavaScript对象中的成员变量迭代？
``` javascript
for(var prop in obj){
  // bonus points for hasOwnProperty
  if(obj.hasOwnProperty(prop)){
  // do something here
  }
}
```

---

# 请描述你经历过的JavaScript单元测试。
目的：保证js代码质量，特别是js类库代码的质量
测试框架：jsunit

---

## Java和JavaScript有什么不同
| Java	| JavaScript |
| ---- | ---- |
| Java是一种OOP编程语言。 |	JavaScript是一种OOP脚本语言。 |
| 它创建在虚拟机或浏览器中运行的应用程序。 |	代码在浏览器或node环境上运行。 |
| 需要编译Java代码。 |	JS代码都是文本的形式。 |

JS的特性：JavaScript 是一种轻量级的解释型编程语言，具有面向对象的特性。补充和集成了 Java，HTML。允许各位在其他静态HTML页面中构建交互性。 该语言的通用核心已嵌入Netscape，Internet Explorer和其他Web浏览器中。

JS的优点:
- 更少的服务器交互 - 在将页面发送到服务器之前，可以验证用户输入,节省了服务器流量，意味着服务器的负载更少
- 立即反馈 - 用户不需要等待页面重新加载来查看是否忘记输入某些内容。
- 增强交互 - 在界面中，当用户使用鼠标悬停或通过键盘激活它们时会做出响应。
- 丰富的接口 - 可以使用JS包含拖放组件和滑块等项，为网站提供丰富的界面。

---

## 是否可以将匿名函数分配给变量并将其作为参数传递给另一个函数

可以。一个匿名函数可以分配给一个变量，它也可以作为参数传递给另一个函数。

问题11：JS中的参数对象是什么&如何获得传递给函数的参数类型

JS 变量arguments表示传递给函数的参数。 使用typeof运算符，可以获得传递给函数的参数类型。如下：

function func(x){

console.log(typeof x, arguments.length);

}

func(); //==> "undefined", 0

func(7); //==> "number", 1

func("1", "2", "3"); //==> "string", 3

问题12：JS中变量的作用域是什么

变量的作用域是程序中定义它的区域，JS变量只有两个作用域：

　●　全局变量 - 全局变量具有全局作用域，这意味着它在JS代码中的任何位置都可见。

　●　局部变量 - 局部变量仅在定义它的函数中可见，函数参数始终是该函数的本地参数。

---

## 回调
回调函数是作为参数或选项传递给某个方法的普通JS函数。它是一个函数，在另一个函数完成执行后执行，因此称为回调。在JS中，函数是对象，因此，函数可以接受函数作为参数，并且可以由其他函数返回。

---

## 列出一些内置方法及其返回的值。
| 内置方法	| 返回值 |
| ---- | ----|
| CharAt()	| 它返回指定索引处的字符。|
| Concat()	| 它连接两个或多个字符串。|
| forEach()	| 它为数组中的每个元素调用一个函数。|
| indexOf()	| 它返回指定值第一次出现时调用字符串对象中的索引。|
| pop()	| 它从数组中删除最后一个元素并返回该元素。|
| push()	| 它将一个或多个元素添加到数组的末尾，并返回数组的新长度。|
| reverse()	| 反转数组元素的顺序。|

---

## JS中的变量命名约定是什么？
不应该使用任何JS保留关键字作为变量名。例如，break或boolean变量名无效。
JS 变量名不应该以数字(0-9)开头。它们必须以字母或下划线开头。
JS 变量名区分大小写。例如，Test和test是两个不同的变量。

---
typeof运算符用于获取其操作数的数据类型。 操作数可以是文字或数据结构，例如变量，函数或对象。 它是一个一元运算符，放在它的单个操作数之前，可以是任何类型。 它的值是一个字符串，表示操作数的数据类型。

---

## cookie
**创建cookie**：
最简单方法是为document.cookie对象分配一个字符串值，如下所示:
document.cookie = "key1 = value1; key2 = value2; expires = date";
**读取cookie**：
document.cookie的值是由分号分隔的name=value对的列表，其中name是cookie的名称，value是其字符串值。
可以使用split()方法将字符串分解为键和值。
**删除cookie**：以便后续尝试读取cookie，则只需将过期日期设置为过去的时间。 咱们应该定义cookie路径以确保删除正确的cookie。 如果未指定路径，某些浏览器将不允许咱们删除cookie。

---

## Attribute 和Property之间有什么区别
- property是DOM中的属性，是JavaScript里的对象；
- attribute是HTML标签上的特性，它的值只能够是字符串；
[Attribute与Property大详解](https://www.cnblogs.com/lmjZone/p/8760232.html)

---

## 下面是在JS代码中访问 html 元素的方法
- getElementById(‘idname’): 按id名称获取元素
- getElementsByClass(‘classname’): 获取具有给定类名的所有元素
- getElementsByTagName(‘tagname’): 获取具有给定标记名称的所有元素
- querySelector(): 此函数采用css样式选择器并返回第一个选定元素

---

## JS代码在HTML文件中可以以多少种方式使用
- 行内
``` HTML
<input type="button" value="点击有惊喜" onclick="javascript:alert('哈哈哈哈')">
```
- 内部
``` HTML
<!DOCTYPE html>

<html lang="en">

<head>

<meta charset="UTF-8">

<script type="text/javascript">

//声明一个函数(整个文档都可以使用)

function surprise() {

alert('恭喜你中了一百万')/*弹出框*/

}

</script>

</head>

。。。

</html>
``` 
- 外部
``` HTML
<script src="../../js/js4.js" type="text/javascript" charset="utf-8">
```

---

## 什么是类型化语言

类型化语言中，值与值关联，而不是与变量关联，它有两种类型：
**动态**:在这种情况下，变量可以包含多种类型，如在JS中，变量可以取number, string 类型。
**静态**:在这种情况下，变量只能包含一种类型，就像在Java中声明为string的变量只能包含一组字符，不能包含其他类型。

---

## Cookie 与 Local storage 与 Session storage 区别
| 特性 | Cookie |	localStorage |	sessionStorage |
| ---- | ---- | ---- | ---- | 
| 数据的生命期 |	一般由服务器生成，可设置失效时间。如果在浏览器端生成Cookie，默认是关闭浏览器后失效	| 除非被清除，否则永久保存 | 	仅在当前会话下有效，关闭页面或浏览器后被清除 |
| 存放数据大小 |	4K左右 |	一般为 5MB | 5MB |
| 与服务器端通信 |	每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题 |	仅在客户端（即浏览器）中保存，不参与和服务器的通信 | 同（local storage）|
| 易用性	| 需要程序员自己封装，源生的Cookie接口不友好	| 源生接口可以接受，亦可再次封装来对Object和Array有更好的支持 | 同（local storage）|

---

## window 与 document 的区别：
- window:JS 的 window 是一个全局对象，它包含变量、函数、history、location。
- document:document也位于window之下，可以视为window的属性。

---


## innerHTML 和 innerText 的区别
- innerHTML:也就是从对象的起始位置到终止位置的全部内容,包括Html标签。
- innerText:从起始位置到终止位置的内容, 但它去除Html标签

---

## JS中的事件冒泡是什么
事件冒泡是HTML DOM API中事件传播的一种方式，当一个事件发生在另一个元素中的一个元素中，并且两个元素都注册了该事件的句柄时。通过冒泡，事件首先由最内部的元素捕获和处理，然后传播到外部元素。执行从该事件开始，并转到其父元素。然后执行传递给父元素，以此类推，直到body元素。

---

## 如何在JS中将任意基的字符串转换为整数
parseInt(string, radix) 将一个字符串 string 转换为 radix 进制的整数， radix 为介于2-36之间的数,如下：
parseInt("4F", 16)

---

## 2 + 5 + '3'的结果是什么
由于2和5是整数，它们将以数字形式相加。因为3是一个字符串，它将与 7 拼接，结果是73。

---

## JS中的“严格”模式是什么以及如何启用？
严格模式是在代码中引入更好的错误检查的一种方法。
- 当使用严格模式时，不能使用隐式声明的变量，或为只读属性赋值，或向不可扩展的对象添加属性。
- 可以通过在文件，程序或函数的开头添加“use strict”来启用严格模式

---

## 下面代码的输出是什么？
``` javascript
var Y = 1;
if (eval(function f(){}))
{
  y += typeof F;
}
console.log(y);
```
打印undefined。if条件语句使用eval求值，因此eval(function f(){})返回函数f(){}(为真)。因此，在if语句中，执行typeof f返回undefined，因为if语句代码在运行时执行，而if条件中的语句在运行时计算。

---

## 如何在JS中清空数组
- 方法一：
``` javascript
arrayList = []
```
上面的代码将把变量arrayList设置为一个新的空数组。如果在其他任何地方都没有对原始数组arrayList的引用，则建议这样做，因为它实际上会创建一个新的空数组。咱们应该小心使用这种清空数组的方法，因为如果你从另一个变量引用了这个数组，那么原始的引用数组将保持不变。
- 方法二：
``` javascript
arrayList.length = 0;
```
上面的代码将通过将其length设置为0来清除现有数组。这种清空数组的方式还会更新指向原始数组的所有引用变量。 因此，当你想要更新指向arrayList的所有引用变量时，此方法很有用。
- 方法三：
``` javascript
arrayList.splice(0, arrayList.length);
```
这处方法也行，当然这种清空数组的方法也将更新对原始数组的所有引用。
- 方法四：
``` javascript
while(arrayList.length)
{
  arrayList.pop();
}

```
上面的实现也可以空数组，但通常不建议经常使用这种方式。

---

``` javascript
var output = (function(x)
  {
    delete x;
    return x;
  }
  )(0);

console.log(output);
```
打印 0。delete操作符用于从对象中删除属性。这里x不是一个对象，而是一个局部变量，删除操作符不影响局部变量。

``` javascript
var X = { foo : 1}; 
var output = (function() 
{ 
  delete X.foo; 
  return X.foo; 
} 
)(); 

console.log(output);
```
输出 undefined。delete操作符用于删除对象的属性。X是一个具有foo属性的对象，由于它是一个自调用函数，所以咱们将从对象X中删除foo属性。这样做之后，当咱们试图引用一个被删除的foo属性时，结果是undefined。

---

``` javascript
var foo = function Bar()
{
  return 7;
};
typeof Bar();
```
输出将是引用错误。函数定义只能有一个引用变量作为其函数名。

---

## 为什么要将JS源文件的全部内容包装在一个函数中

这是一种越来越普遍的做法，被许多流行的JS库所采用。 这种技术围绕文件的整个内容创建一个闭包，最重要的是，它可以创建一个私有命名空间，从而有助于避免不同JS模块和库之间潜在的名称冲突。

该技术的另一个特性是允许为全局变量提供一个简单的别名，这在jQuery插件中经常使用。

---

## JS中的转义字符是什么

JS转义字符使咱们能够在不破坏应用程序的情况下编写特殊字符。转义字符(\)用于处理特殊字符，如单引号、双引号、撇号和&号，在字符前放置反斜杠使其显示。

如：document.write("I am a \"good\" boy")

---

``` javascript
(function() {
   var a = b = 5;
})();
console.log(b);
```
上述代码会打印出 5 。
这个问题的陷阱就是，在立即执行函数表达式（IIFE）中，有两个命名，但是其中变量是通过关键词 var 来声明的。这就意味着 a 是这个函数的本地变量。与此相反， b 是属于这个函数的全局变量的。
这个问题另一个陷阱就是，在函数中他没有使用 "严格模式" ( 'use strict'; )。如果 严格模式 开启，那么代码就会报出未捕获引用错误（Uncaught ReferenceError）：b没有定义。记住严格模式要求，如果这个是预期的行为，你需要明确地引用全局变量，。因此，你需要像下面这么写：
``` javascript
(function() {
   'use strict';
   var a = window.b = 5;
})();
console.log(b);
```

---

## 创建原生方法
在 String 对象上定义一个 repeatify 函数。这个函数接受一个整数参数，来明确字符串需要重复几次。这个函数要求字符串重复指定的次数。举个例子：
``` javascript
console.log('hello'.repeatify(3))
```
实现方法：
``` javascript
// 首先判断该函数是否存在
String.prototype.repeatify = String.prototype.repeatify || function(times) {
  var str = '';
  for (var i = 0; i < times; i++) {
  str += this;
  }
  return str;
};
```

---

请实现一个函数，运算结果可以满足如下预期结果：
``` javascript
add(1)(2) // 3
add(1, 2, 3)(10) // 16
add(1)(2)(3)(4)(5) // 15
```
看到题目首先想到的是会用到高阶函数以及 Array.prototype.reduce()。
高阶函数(Higher-order function)：高阶函数的意思是它接收另一个函数作为参数。在 javascript 中，函数是一等公民，允许函数作为参数或者返回值传递。

得到了下面这个解法：
``` javascript
function add () {
  // Array.prototype.slice.call(arguments)能将具有length属性的对象转成数组，除了IE下的节点集合（因为ie下的dom对象是以com对象的形式实现的，js对象与com对象不能进行转换）
  var args = Array.prototype.slice.call(arguments);
  var fn = function () {
    var arg_fn = Array.prototype.slice.call(arguments);
    return add.apply(null, args.concat(arg_fn));
  }
  fn.valueOf = function () {
    return args.reduce(function(a, b) {
      return a + b;
    })
  }
  return fn;
}
```
---

## 作用域
1. 全局变量：
   - 在全局范围内声明的变量，如var a=1;
   - 只有赋值没有声明的值，如a=2; （注：如果a=2在函数环境中，也是全局变量）
2. 局部变量：
写入函数中的变量，叫做局部变量。
3. 作用：
   - 程序的安全。
   - 内存的释放。
4. 作用域链：
查找量的过程。先找自己局部环境有没有声明或者是函数，如果有，则查看声明有无赋值或者是函数的内容，如果没有，则向上一级查找。
5. 预解析顺序：
每个程序都要做的工作，程序开始先预解析语法，标点符号是否有误，解析内存是否可容纳，解析变量……直到解析无误了，才开始按正常的流程顺序走。试想一下，如果没有预解析顺序，直接按流程顺序走，可能程序执行到最后一个函数，发现了语法错误，才开始报错，那性能要有多差啊！
**顺序内容**：
1.文件内引用的 < script > 块依次解析，从上到下连成一片。
2.每个script块内部的var（注意：只解析变量名，不解析值，如var a=2;将var a解析在环境的开头，并不解析后面的值，只有当程序执行到var a=2这行时，才会给变量赋值），function解析到本块的开头。
3.依次解析每个环境，将var,function解析到环境的开头。

6. 应用场景（一些常见的作用域相关的面试题）：
``` javascript
var a="aa";
function test(){
 alert(a);//undefined，函数执行后，在函数环境内，var a会预解析，当弹出a时，首先先找本层环境内有无声明，发现有。但是代码没有执行到赋值，所以结果是undefined。
 var a="bb";//var a会预解析在函数开头，执行到这行才进行赋值
 alert(a);//“bb”
}
test();
alert(a);//"aa" 找全局环境下的声明，找到了var a="aa"


var a="aa";
function test(){
 alert(a);//“aa”，函数执行后，在函数环境内，没有找到本层环境关于a的声明，所以开始向上一层环境查找。
 a="bb";//执行到这行开始改变全局a的量
}
test();
alert(a);//"bb" 全局环境的a在函数执行时已经被改变


function test(){ 
 b();//函数b会被预解析，因此可以调用，执行了输出1；
 var a=1;
 function b(){
  console.log(1);
  console.log(a);//undefined
  var a=2;
 }
}
test();
```