# JS篇 —— 面试题

## 数据类型
数据类型主要包括两部分：

**基本数据类型**： Undefined、Null、Boolean、Number 和 String
**引用数据类型**： Object (包括 Object 、Array 、Function)
ECMAScript 2015 新增:Symbol(创建后独一无二且不可变的数据类型 )

---
## 判断一个值是什么类型有哪些方法？
* typeof 运算符
* instanceof 运算符
* Object.prototype.toString 方法

---
## null 和 undefined 的区别？
null 表示一个对象被定义了，值为“空值”；
undefined 表示不存在这个值。
1. 变量被声明了，但没有赋值时，就等于undefined。 
2. 调用函数时，应该提供的参数没有提供，该参数等于undefined。
3. 对象没有赋值的属性，该属性的值为undefined。 
4. 函数没有返回值时，默认返回undefined。

---
## 怎么判断一个变量arr的话是否为数组（此题用 typeof 不行）？
arr instanceof Array
arr.constructor == Array
Object.protype.toString.call(arr) == '[Object Array]'

---
## “===、 ==”的区别？
* ==：当且仅当两个运算数相等时，它返回 true，即不检查数据类型
* ===：只有在无需类型转换运算数就相等的情况下，才返回 true，需要检查数据类型

---
## eval是做什么的？
eval() 函数会将传入的字符串当做 JavaScript 代码进行执行。
它的功能是把对应的字符串解析成 JS 代码并运行；
应该避免使用 eval，不安全，非常耗性能（2次，一次解析成 js 语句，一次执行）。

---
## 箭头函数有哪些特点？
不需要function关键字来创建函数
省略return关键字
改变this指向

---
## var、let、const 区别？
var 存在声明提升，声明覆盖。
let 只能在块级作用域内访问。
const 用来定义常量，必须初始化，不能修改（对象特殊）

---
## new操作符具体干了什么呢？
1. 创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型。
2. 属性和方法被加入到 this 引用的对象中。
3. 新创建的对象由 this 所引用，并且最后隐式的返回 this 。

1.  JSON 的了解？
JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。
它是基于JavaScript的一个子集。数据格式简单, 易于读写, 占用带宽小
{'age':'12', 'name':'back'}

11. documen.write 和 innerHTML 的区别？
document.write 只能重绘整个页面
innerHTML 可以重绘页面的一部分

12. ajax过程？
(1)创建XMLHttpRequest对象,也就是创建一个异步调用对象.
(2)创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息.
(3)设置响应HTTP请求状态变化的函数.
(4)发送HTTP请求.
(5)获取异步调用返回的数据.
(6)使用JavaScript和DOM实现局部刷新.

13. 请解释一下 JavaScript 的同源策略？
概念:同源策略是客户端脚本（尤其是Netscape Navigator2.0，其目的是防止某个文档或脚本从多个不同源装载。
这里的同源策略指的是：协议，域名，端口相同，同源策略是一种安全协议。
指一段脚本只能读取来自同一来源的窗口和文档的属性。

14. 介绍一下闭包和闭包常用场景？
闭包是指有权访问另一个函数作用域中的变量的函数，创建闭包常见方式，就是在一个函数的内部创建另一个函数
使用闭包主要为了设计私有的方法和变量，闭包的优点是可以避免变量的污染，缺点是闭包会常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。在js中，函数即闭包，只有函数才会产生作用域的概念。
闭包有三个特性：
函数嵌套函数
函数内部可以引用外部的参数和变量
参数和变量不会被垃圾回收机制回收
应用场景，设置私有变量的方法
不适用场景：返回闭包的函数是个非常大的函数
闭包的缺点就是常驻内存，会增大内存使用量，使用不当会造成内存泄漏
15. javascript的内存(垃圾)回收机制？
垃圾回收器会每隔一段时间找出那些不再使用的内存，然后为其释放内存
一般使用标记清除方法(mark and sweep), 当变量进入环境标记为进入环境，离开环境标记为离开环境
垃圾回收器会在运行的时候给存储在内存中的所有变量加上标记，然后去掉环境中的变量以及被环境中变量所引用的变量（闭包），在这些完成之后仍存在标记的就是要删除的变量了
还有引用计数方法(reference counting), 在低版本IE中经常会出现内存泄露，很多时候就是因为其采用引用计数方式进行垃圾回收。引用计数的策略是跟踪记录每个值被使用的次数，当声明了一个 变量并将一个引用类型赋值给该变量的时候这个值的引用次数就加1，如果该变量的值变成了另外一个，则这个值得引用次数减1，当这个值的引用次数变为0的时 候，说明没有变量在使用，这个值没法被访问了，因此可以将其占用的空间回收，这样垃圾回收器会在运行的时候清理掉引用次数为0的值占用的空间。
在IE中虽然JavaScript对象通过标记清除的方式进行垃圾回收，但BOM与DOM对象却是通过引用计数回收垃圾的， 也就是说只要涉及BOM及DOM就会出现循环引用问题。
16. JavaScript原型，原型链 ? 有什么特点？
每个对象都会在其内部初始化一个属性，就是prototype(原型)，当我们访问一个对象的属性时，
如果这个对象内部不存在这个属性，那么他就会去prototype里找这个属性，这个prototype又会有自己的prototype，
于是就这样一直找下去，也就是我们平时所说的原型链的概念。
关系：instance.constructor.prototype = instance.proto
特点：
JavaScript对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与之相关的对象也会继承这一改变。

---
## 深拷贝和浅拷贝
1. 基本数据类型的赋值不算拷贝
2. 数组和对象的赋值为浅拷贝
3. 解构赋值时，针对一维数组和对象可以看作深拷贝，多维数组为浅拷贝
4. JSON转化后为深拷贝
``` JavaScript
let newList = JSON.parse(JSON.stringify(list));
```
5. 标准深拷贝写法
``` JavaScript
function deepClone(source){
  // [] => Array(基类); {} => Object
  const targetObj = source.constructor === Array ? [] : {};
  for(let keys in source) {
    if(source.hasOwnProperty(keys)){
      // keys => 3
      // 引用数据类型
      if(source[keys] && typeof source[keys] === 'object'){
        targetObj[keys] = source[keys].constructor === Array ? [] : {};
        // 递归
        targetObj[keys] = deepClone(source[keys])
      }
      else{
        // 基本数据类型，直接赋值
        targetObj[keys] = source[keys]
      }
    }
  }
  return targetObj
}
```

***补充知识*** 
*1.hasOwnProperty()函数用于指示一个对象自身(不包括原型链)是否具有指定名称的属性。如果有，返回true，否则返回false。
2.说简单点，它能帮你指向你当前循环的对象，而过滤掉原型链上其它对象，因为在工作中我们很难保证其他人是否会修改原型链，这样做会更为保险。
3.因为 for in 循环总是遍历整个原型链，所以当遍历多继承的对象时效率较低。
4.为了检查某个对象是否拥有不在原型链上的自定义属性，就有必要用到 hasOwnProperty 方法，任何一个对象都具有该方法，它继承自 Object.prototype。
5.当检测某个对象是否拥有某个属性时，hasOwnProperty 是唯一可以完成这一任务的方法，在 for in 循环时，建议增加 hasOwnProperty 进行判断，可以有效避免扩展本地原型而引起的错误。
6.我们无法完全检测某个属性是否是undefined，因为属性有可能存在，但其值为undefined。
7.hasOwnProperty 是Javascript中唯一一个可以处理对象属性而不遍历原型链的方法。
个人认为hasOwnProperty()的主要作用就是在多重循环中过滤掉不符合条件的对象，减少遍历次数，和其他编程语言中的continue和break类似。*

---

## map与set的区别
- set是一种集合数据结构，以[value]形式存储元素
- Map是一种字典数据结构，以[key: value]的形式存储元素

---

## 构造函数与普通函数的区别
1. 命名方式
   构造名称通常首字母大写，普通小写
2. this指向
   构造this会绑定到创建的对象实例上
   普通this属于此函数的调用者
3. 调用方式
   构造函数需要new运算符调用，如果构造没有参数可以省略小括号，如new Object
   普通不需要new，必须要小括号

---

## 